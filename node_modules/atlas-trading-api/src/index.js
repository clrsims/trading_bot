import fetch from 'node-fetch';
import sha256 from 'js-sha256';

function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

export default function makeBot(url, guildId, password, name, verbose = true, retry = true) {
  const prefix = `${url}/guilds/${guildId}`
  const id = sha256(password)

  function log(...args) {
    if(name) console.log(`[${name}]`, ...args);
    else console.log(...args);
  }

  const bot = {
    id: id,
    name: name,
    verbose: verbose,
    guildId: guildId,
    url: url,

    getMarketData: async (market) => {
      const response = await fetch(`${prefix}/markets/${market}`, {
        headers: {
          'Content-Type': 'application/json'
        },
        method: 'POST',
        body: JSON.stringify({
          auth: password
        })
      })
      const data = await response.json()
      if(data.success)
        return data.result;
      if(data.result.rateLimited && retry) {
        const delay = 5000.0;
        if(verbose) log(`Rate limited, waiting ${delay}ms to try again.`);
        await sleep(delay);
        return await bot.getMarketData(market);
      }
      throw new Error(data.result.errorMessage);
    },

    getPortfolio: async () => {
      const response = await fetch(`${prefix}/users/${id}/portfolio`, {
        headers: {
          'Content-Type': 'application/json'
        },
        method: 'POST',
        body: JSON.stringify({
          auth: password
        })
      });
      const data = await response.json();
      if(data.success)
        return data.result;
      if(data.result.rateLimited && retry) {
        const delay = 5000.0;
        if(verbose) log(`Rate limited, waiting ${delay}ms to try again.`);
        await sleep(delay);
        return await bot.getPortfolio();
      }
      throw new Error(data.result.errorMessage);
    },

    placeOrder: async (market, type, price, size) => {
      if(type == "bid") {
        if(verbose) log(`${market}: ${price} for ${size} contracts`)
      } else if(type == "offer") {
        if(verbose) log(`${market}: ${size} contracts at ${price}`)
      } else {
        throw new Error(`Invalid order type "${type}"`);
      }
      const response = await fetch(`${prefix}/markets/${market}/order`, {
        headers: {
          'Content-Type': 'application/json'
        },
        method: 'POST',
        body: JSON.stringify({
          auth: password,
          type: type,
          price: price,
          size: size
        })
      });
      const data = await response.json();
      if(data.success)
        return data.result;

      if(data.result.rateLimited && retry) {
        const delay = 5000.0;
        if(verbose) log(`Rate limited, waiting ${delay}ms to try again.`);
        await sleep(delay);
        return await bot.placeOrder(market, type, price, size);
      }
      // check if result includes "You would risk"
      if(data.result.errorMessage && data.result.errorMessage.includes("You would risk")) {
        log("ORDER FAILED due to insufficient funds")
        return data.result;
      }
      throw new Error(data.result.errorMessage);
    },

    out: async (market, price=null) => {
      if(price) {
        if(verbose) log(`${market}: out at price ${price}`)
      } else {
        if(verbose) log(`${market}: out all orders`)
      }
      const response = await fetch(`${prefix}/markets/${market}/out`, {
        headers: {
          'Content-Type': 'application/json'
        },
        method: 'POST',
        body: JSON.stringify(price ? {
          auth: password,
          price: price
        } : {
          auth: password
        })
      });
      const data = await response.json();
      
      if(data.success)
        return data.result;

      if(data.result.rateLimited && retry) {
        const delay = 5000.0;
        if(verbose) log(`Rate limited, waiting ${delay}ms to try again.`);
        await sleep(delay);
        return await bot.out(market, price);
      }
      throw new Error(data.result.errorMessage);
    },

    redeem: async (shares) => {
      if(verbose) log(`redeem ${shares} shares of ETF`)

      const response = await fetch(`${prefix}/redeem`, {
        headers: {
          'Content-Type': 'application/json'
        },
        method: 'POST',
        body: JSON.stringify({
          auth: password,
          shares: shares
        })
      });
      const data = await response.json();
      
      if(data.success)
        return data.result;

      if(data.result.rateLimited && retry) {
        const delay = 5000.0;
        if(verbose) log(`Rate limited, waiting ${delay}ms to try again.`);
        await sleep(delay);
        return await bot.redeem(shares);
      }
      throw new Error(data.result.errorMessage);
    }
  }
  return bot;
}


